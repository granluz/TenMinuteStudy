#include <iostream>

using namespace std;

int main() {
	//지금까지의 변수 선언 과정

	int val = 3;
	/*
	변수의 데이터형 기호 이름을 제공하면 그 값을 저장하기 위한 메모리를 대입하고
	그 위치를 내부적으로 추적할 수 있게 된다.
	>>이 프로그램에서 내부적으로 메모리를 대입한 공간을 주소라고 부른다.
	*/

	cout << &val << endl;
	//& = 주소 연산자를 통하여 프로그램이 값을 메모리 어디에 저장했는지 확인 할 수 있다.
	//16진수 표기가 메모리를 나타내는 가장 일반적인 방법이기에 보통의 주소 출력은 16진수 표기를 사용한다.

	//C++ : 객체지향 프로그래밍
	/*
	특징
	프로그램이 코드를 읽는 컴파일 시간이 아닌 코드가 실행되어 돌아가는 시간에 어떠한 결정을 내릴 수 있다.
	>> 배열을 생성
	절차지향 프로그래밍 : 배열의 크기가 미리 결정되어야 한다.
	객체지향 프로그래밍 : 배열의 크기를 실행 시간에 결정할 수 있다.
	>> 배열의 사이즈가 [20]인 배열을 사용하다가 일주일에 한번 정도만 [200]개의 값을 저장해야한다면?
	절차지향 : 미리 200의 배열 공간을 사용해야한다. = 180개가 낭비
	객체지향 : 실행시간에 결정을 내릴 수 있기 때문에 배열이 [20]개로 충분하면, [20]개의 배열만 생성하고,
	>>간헐적으로 [200]개가 필요할때 모두 담을 수 있는 사이즈의 배열을 선언 할 수 있다.  
	*/

	/*포인터의 요지는 기존 변수 선언에서는 변수의 이름을 통해 변수를 관리했으나
	>> 포인터 : 사용할 주소에 이름을 붙인다.
	>> 즉 포인터는 포인터의 이름이 주소를 나타낸다.
	// 간접값 연산자, 간접 참조 연산자 '*'을 통해 나타낸다.
	*/

	/*
	int *a; //c style
	int* b; //c++ style
	int* c, d; // ','를 사용하여 나열해서 선언시 가장 앞의 c는 포인터 변수, d는 int변수가 된다.
	*/
	
	int a = 6; // int 형 변수 a를 선언하고 값을 6으로 초기화한다.
	int* b; //int형 포인터 변수 b를 선언한다 
	//b 는 그 자체로 이제 b라는 주소를 나타낸다.

	b = &a;//주소 연산자를 사용하여 b에 a의 주소값을 넣어준다.

	cout << "a의 값 " << a << endl;
	cout << "*b의 값 " << *b << endl; //포인터로 선언된 변수의 값을 확인할 때는 간접참조 연산자 '*'를 붙여야 한다.
	cout << endl;
	cout << "a의 주소 " << &a << endl;
	cout << "*b의 주소 " << b << endl;//포인터로 선언된 변수의 주소를 확인할 때는 아무것도 붙이지 않는다. 그 자체가 주소

	*b = *b + 1;
	/*포인터의 값에 1을 더했는데 a 의 값이 7이되었다.
	>>포인터는 개념적으로는 정수와 다른 데이터이다.
	정수 : 뺄셈 덧셈 곱셈 나눗셈을 할 수 있는 '수'.
	포인터 : 위치를 나타내는 주소
	>>포인터에는 정수를 직접 대입하는것이 아무런 의미가 없다.
	포인터변수에 int a의 주소를 대입하여 그 주소의 값을 수정하는 것이 가능하다.
	*/
	cout << "이제 a의 값은 " << a << endl;

	return 0;
}