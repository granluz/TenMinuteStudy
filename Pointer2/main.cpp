#include <iostream>

using namespace std;

int main() {
	//new 연산자
	/*
	1. 어떤 데이터형을 원하는지 new 연산자에게 알려준다
	2. new 연산자는 그 데이터형에 알맞은 크기의 메모리 블록을 찾는다
	3. 그 블록의 주소를 리턴한다.
	*/
	int a;
	int* b = &a;
	//이전시간에는 포인터 변수 b에 a의 주소를 대입했다.

	int* pointer = new int;
	/*
	new int == int형 데이터를 지정할 수 있는 새로운 메모리가 필요하다고 알려준다.
	new 연산자는 데이터형을 확인하고 몇 바이트가 필요한지 계산한다.
	4byte를 저장할 수 있는 메모리 주소를 찾아 pointer에 리턴해준다.
	*/
	/*
	지시하는 메모리의 주소 변수 이름이 없다.
	>>접근 가능한 이유는 포인터가 데이터의 객체(어떠한 것)를 지시하고 있다라고 표현한다.
	>>이러한 방식은 메모리 제어권을 사용자에게 준다.
	*/

	//delete 연산자
	/*
	사용한 메모리를 다시 메모리 폴로 환수
	환수된 메모리는 프로그램의 다른 부분이 다시 사용 가능
	*/
	
	int* ps = new int;
	// new를 사용하여 포인터 변수 ps를 선언
	// 어떠한 코드를 통해 해당 메모리 사용
	delete ps;
	//ps에 할당된 메모리를 프로그램에 반환
	//delete를 안할시 메모리 누수 발생.
	/*
	delete 규칙 4가지
	1. new로 대입하지 않은 메모리는 delete로 해제할 수 없다.
	2. 같은 메모리 블록을 연달아 두 번 delete로 해제할 수 없다.
	3. new[]로 메모리를 대입할 경우 delete[]로 해제한다.
	4. 대괄호를 사용하지 않았다면 delete도 대괄호를 사용하지 않아야 한다.
	*/

	double* p3 = new double[3]; //double형 데이터 3개를 저장할 수 있는 공간을 p3에 대입한다.
	//>> p3를 배열 이름처럼 취급하여 []를 하지 않아도 된다.

	p3[0] = 0.2;//인덱스에 값을 초기화 한다.
	p3[1] = 0.5;
	p3[2] = 0.8;

	cout << "p3[1] is " << p3[1] << "." << endl;

	p3 = p3 + 1; //포인터를 1씩 증가시킨다.
	//배열의 이름이라면 틀린 표현이다.
	//>> 포인터는 변수처럼 사용할 수 있기에 값을 변경할 수 있다.
	cout << "Now p3[0] is " << p3[0] << " and " << endl;
	
	cout << "p3[1] is " << p3[1] << "." << endl;

	p3 = p3 - 1; //다시 시작 위치를 지시한다.
	delete[] p3; // p3는 3개의 공간을 가지고 있으므로 []로 delete해 메모리를 해제한다.
	return 0;
}